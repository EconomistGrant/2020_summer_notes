# Power of 3 and 5
trivial

# Identical Distribution

# Task Queue 
trivial
numTask % batchSize * processing time, max

# Oscillating strings

# Bucket Fill

# Circular Array
应该也不难
iterate through endNode

if endNode[i] > endNode[i]:
    Node[endNode[i]] += 1
else: 
    Node[endNode[i]] +=1
    num_circle += 1

for endNode[0]<= j <= endNode[size-1]
    node[j] -= 1

# Connecting computers
comp_edges < comp -1 return -1

//get number of subgraphs, #uptree - 1

vector<int> uptree (comp_nodes, -1)
for i < comp_edges
    if uptree[c_from[i]] == -1 & uptree[c_to[i]] == -1:
        uptree[c_to[i]] = c_from[i]
    if uptree[c_from[i]] != -1 & uptree[c_to[i]] == -1:
        cur_node = c_from[i]
        while(uptree[cur_node] != -1)  
            cur_node = uptree[cur_node]
        uptree[c_to[i]] = curnode
    else:
        //合并两个uptree

